import decimal
from tqdm import tqdm
decimal.getcontext().prec = 10000

class Pi:
    
    def __init__(self, iterations, piDict = {"iterations" : decimal.Decimal(0)}) -> None:
        #Raises exceptions if piDict is anything other than expected value
        if type(piDict) != dict:
            raise TypeError("piDict parameter must be a valid dictionary.")
        try:
            piDict["iterations"]
        except KeyError:
            raise ValueError("Invalid dictionary: Please only use dictionaries generated by the pi algorithm.")
        if piDict["iterations"] == 0 and len(piDict) != 1:
            raise ValueError("Invalid dictionary: Please only use dictionaries generated by the pi algorithm.")
        if len(piDict) != 1 and len(piDict) != 3:
            raise ValueError("Invalid dictionary: Please only use dictionaries generated by the pi algorithm.")
        if len(piDict) == 3:
            try:
                piDict["pi"]
                piDict["alg"]
            except KeyError:
                raise ValueError("Invalid dictionary: Please only use dictionaries generated by the pi algorithm.")
            if type(piDict["iterations"]) != decimal or type(piDict["pi"]) != decimal or type(piDict["alg"]) != str:
                raise ValueError("Invalid dictionary: Please only use dictionaries generated by the pi algorithm.")

        self.t = piDict["iterations"]
        self.newIterations = iterations
        
        if self.t == 0:
            self.pi = 0
            self.alg = ""
        else:
            self.alg = piDict["alg"]
            self.pi = piDict["pi"]


    def LeibnizSeries(lei):
    #Leibniz formula for π
    #π=(4/1)-(4/3)+(4/5)-(4/7)+(4/9)-(4/11)+(4/13)-(4/15)...
    #https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80

        if lei.alg != "lei" or lei.alg != "":
            raise Exception("Using wrong algorithm for dictionary.")

        if lei.pi == 0:
            lei.pi = 4

        #Calculates where to start based off of iterations already completed
        d = lei.t * 2 + 3
        if lei.t % 2 == 0:
            mathSym = "sub"
        else:
            mathSym = "add"

        #Performs the calculations
        for i in tqdm(range(lei.newIterations)):
            if mathSym == "sub":
                lei.pi = lei.pi - (4 / d)
                mathSym = "add"
            else:
                lei.pi = lei.pi + (4 / d)
                mathSym = "sub"
            d = d + 2
        lei.t = lei.t + i + 1

        piDict = {"pi" : lei.pi,
                    "iterations" : lei.t,
                    "alg" : "lei"
                    }.__dict__
        #Returns dictionary
        return(piDict)

    def NilakanthaSeries(nil):
    #Nilakantha series for π
    #π=3+4/(2·3·4)-4/(4·5·6)+4/(6·7·8)-4/(8·9·10)+4/(10·11·12)-4/(12·13·14)...
    #https://www.mathscareers.org.uk/calculating-pi/

        if nil.alg != "lei" or nil.alg != "":
            raise Exception("Using wrong algorithm for dictionary.")

        if nil.pi == 0:
            nil.pi = 3


        #Calculates where to start based off of iterations already completed
        d = [nil.t*2+2 , nil.t*2+3, nil.t*2+4]
        if nil.t % 2 == 0:
            mathSym = 'add'
        else:
            mathSym = 'sub'

        #Performs the calculations
        for i in tqdm(range(nil.newIterations)):
            if mathSym == 'add':
                nil.pi = nil.pi + 4 / (d[0] * d[1] * d[2])
                mathSym = 'sub'
            else:
                nil.pi = nil.pi - 4 / (d[0] * d[1] * d[2])
                mathSym = 'add'
            d = [d[2], d[2]+1, d[2]+2]
        nil.t = nil.t + i + 1

        pi = nil.pi
        t = nil.t
        piDict = {"pi" : nil.pi,
                  "iterations" : nil.t,
                  "alg" : "nil"
                  }.__dict__

        #Returns dictionary
        return(piDict)



"""
def LeibnizSeries(piDict, iterations):
#Leibniz formula for π
#π=(4/1)-(4/3)+(4/5)-(4/7)+(4/9)-(4/11)+(4/13)-(4/15)...
#https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80

    #Decimal for increased accuracy and tqdm for progress bar
    import decimal
    from tqdm import tqdm
    decimal.getcontext().prec = 10000

    #Determines if data exists or not
    if piDict == 'new':
        #Assigns starting variables
        t = decimal.Decimal(0)
        pi = decimal.Decimal(4)    
    else:
        #Unpackages dictionary
        pi = piDict["calculatedPi"]
        t = piDict["totalIterations"]

    #Calculates where to start based off of iterations already completed
    d = t * 2 + 3
    if t % 2 == 0:
        mathSym = 'sub'
    else:
        mathSym = 'add'

    #Performs the calculations
    for i in tqdm(range(iterations)):
        if mathSym == 'sub':
            pi = pi - (4 / d)
            mathSym = 'add'
        else:
            pi = pi + (4 / d)
            mathSym = 'sub'
        d = d + 2
    t = t + i + 1

    #Packages and returns dictionary
    piDict = {
        "calculatedPi" : pi,
        "totalIterations" : t,
    }

    return(piDict)

def NilakanthaSeries(piDict, iterations):
#Nilakantha series for π
#π=3+4/(2·3·4)-4/(4·5·6)+4/(6·7·8)-4/(8·9·10)+4/(10·11·12)-4/(12·13·14)...
#https://www.mathscareers.org.uk/calculating-pi/

    #Decimal for increased accuracy and tqdm for progress bar
    import decimal
    from tqdm import tqdm
    decimal.getcontext().prec = 10000

    #Determines if data exists or not
    if piDict == 'new':
        #Assigns starting variables
        t = decimal.Decimal(0)
        pi = decimal.Decimal(3)   
    else:
        #Unpackages dictionary
        pi = piDict["calculatedPi"]
        t = piDict["totalIterations"]
        
    #Calculates where to start based off of iterations already completed
    d = [t*2+2 , t*2+3, t*2+4]
    if t % 2 == 0:
        mathSym = 'add'
    else:
        mathSym = 'sub'

    #Performs the calculations
    for i in tqdm(range(iterations)):
        if mathSym == 'add':
            pi = pi + 4 / (d[0] * d[1] * d[2])
            mathSym = 'sub'
        else:
            pi = pi - 4 / (d[0] * d[1] * d[2])
            mathSym = 'add'
        d = [d[2], d[2]+1, d[2]+2]

    #Updates running iteration counter
    t = t + i + 1

    #Packages and returns dictionary
    piDict = {
        "calculatedPi" : pi,
        "totalIterations" : t,
    }

    return(piDict)
"""

def readData(file):
    import pickle
    dataFile= open(file, 'rb')     
    data = pickle.load(dataFile)
    dataFile.close()
    return(data)


def writeData(file, data):
    import pickle
    dataFile= open(file, 'wb')     
    pickle.dump(data, dataFile)
    dataFile.close()
